# Analyzing SiteScanner Results

This document provides examples of how to perform basic structural analysis on the output PDB files generated by SiteScanner, using the high B-factor assigned to predicted binding site residues.

## Prerequisites

You will need Python with the following libraries installed:

*   **BioPython:** For parsing PDB files.
*   **NumPy:** For numerical calculations.

Install them if you haven't already:
```bash
pip install biopython numpy
```

## Overview of Output Files

SiteScanner produces two key output files for each input PDB (e.g., `input.pdb`):

1.  **`input_predictions.txt`:** Lists the residue IDs (e.g., `A_GLY_101`) predicted as part of the binding site.
2.  **`input_predicted_sites.pdb`:** A copy of the input PDB where atoms belonging to the predicted residues have their B-factor column set to a high value (default: 99.00), while other atoms have a low B-factor (default: 10.00).

We will use the `*_predicted_sites.pdb` file for analysis, identifying predicted residues based on the B-factor.

## Python Analysis Examples

Let's analyze the results for `1a2k` from the demo run.

```python
import numpy as np
from Bio.PDB import PDBParser
from Bio.PDB import is_aa
from collections import Counter

# --- Configuration ---
PDB_FILE_PATH = "../demo/demo_results/1a2k/1a2k_predicted_sites.pdb" # Adjust path as needed
HIGH_BFACTOR_THRESHOLD = 90.0 # Use a value slightly lower than 99.0 to be safe
# -----------------

def get_predicted_site_residues(pdb_path, bfactor_thresh):
    """Parses a PDB file and extracts residues with high B-factors."""
    parser = PDBParser(QUIET=True)
    try:
        structure = parser.get_structure("protein", pdb_path)
    except FileNotFoundError:
        print(f"Error: PDB file not found at {pdb_path}")
        return []

    predicted_residues = []
    # Iterate through all residues, check B-factor of the first atom found
    # Assumes all atoms in a predicted residue have high B-factor
    for residue in structure.get_residues():
        if not is_aa(residue, standard=True):
            continue # Skip non-standard residues

        is_predicted = False
        # Check the B-factor of the first atom to determine if residue is predicted
        try:
            first_atom = next(residue.get_iterator())
            if first_atom.get_bfactor() >= bfactor_thresh:
                is_predicted = True
        except StopIteration: # Handle empty residues if they exist
            continue
        except AttributeError:
             print(f"Warning: Could not get B-factor for an atom in residue {residue.get_id()}")
             continue

        if is_predicted:
            predicted_residues.append(residue)

    print(f"Found {len(predicted_residues)} predicted binding site residues in {pdb_path}")
    return predicted_residues

def calculate_site_centroid(residues):
    """Calculates the geometric centroid of the C-alpha atoms."""
    ca_coords = []
    for residue in residues:
        try:
            ca_atom = residue['CA']
            ca_coords.append(ca_atom.get_coord())
        except KeyError:
            # print(f"Warning: C-alpha atom not found in residue {residue.get_id()}")
            pass # Skip residues without CA for centroid calculation

    if not ca_coords:
        return None

    centroid = np.mean(np.array(ca_coords), axis=0)
    return centroid

def calculate_radius_of_gyration(residues):
    """Calculates the radius of gyration based on C-alpha atoms."""
    ca_coords = []
    for residue in residues:
        try:
            ca_atom = residue['CA']
            ca_coords.append(ca_atom.get_coord())
        except KeyError:
            pass # Skip residues without CA

    if len(ca_coords) < 2:
        return 0.0 # Cannot calculate Rg for 0 or 1 point

    coords_array = np.array(ca_coords)
    centroid = np.mean(coords_array, axis=0)
    # Calculate squared distances from centroid
    sq_distances = np.sum((coords_array - centroid)**2, axis=1)
    # Radius of gyration squared is the mean squared distance
    rg_sq = np.mean(sq_distances)
    rg = np.sqrt(rg_sq)
    return rg

def get_amino_acid_composition(residues):
    """Calculates the frequency of each amino acid type."""
    aa_counts = Counter()
    total_residues = 0
    for residue in residues:
        # Check if it's a standard amino acid again just in case
        if is_aa(residue, standard=True):
            aa_counts[residue.get_resname()] += 1
            total_residues += 1

    composition = {aa: count / total_residues for aa, count in aa_counts.items()} if total_residues > 0 else {}
    return aa_counts, composition

# --- Run Analysis ---
print(f"Analyzing {PDB_FILE_PATH}...")
predicted_residues = get_predicted_site_residues(PDB_FILE_PATH, HIGH_BFACTOR_THRESHOLD)

if predicted_residues:
    # 1. List Residue IDs
    residue_ids = [f"{res.get_parent().id}_{res.get_resname()}_{res.get_id()[1]}" for res in predicted_residues]
    print("\nPredicted Residue IDs:")
    print(", ".join(residue_ids))

    # 2. Calculate Centroid
    centroid = calculate_site_centroid(predicted_residues)
    if centroid is not None:
        print(f"\nPredicted Site Centroid (XYZ): {centroid[0]:.3f}, {centroid[1]:.3f}, {centroid[2]:.3f}")

    # 3. Calculate Radius of Gyration
    rg = calculate_radius_of_gyration(predicted_residues)
    print(f"Predicted Site Radius of Gyration: {rg:.3f} Angstroms")

    # 4. Calculate Amino Acid Composition
    aa_counts, aa_composition = get_amino_acid_composition(predicted_residues)
    print("\nPredicted Site Amino Acid Counts:")
    for aa, count in sorted(aa_counts.items()):
        print(f"  {aa}: {count}")
    print("\nPredicted Site Amino Acid Composition (%):")
    for aa, percentage in sorted(aa_composition.items()):
        print(f"  {aa}: {percentage*100:.1f}%")

else:
    print("No predicted residues found with high B-factor.")

```

## Interpretation

*   **Residue List:** Confirms which residues were selected by the (potentially post-processed) prediction.
*   **Centroid:** Gives the geometric center of the predicted site, useful for visualizing its location or measuring distances.
*   **Radius of Gyration (Rg):** Indicates the spatial extent of the predicted site. A smaller Rg suggests a more compact cluster of residues.
*   **Amino Acid Composition:** Reveals the types of residues enriched in the predicted site, which can provide clues about its chemical properties (e.g., hydrophobic, charged, polar) and potential function.

This script provides a starting point. You can extend it to perform more complex analyses, such as calculating surface accessibility (requires external tools like DSSP or MSMS), comparing the composition to the whole protein, or analyzing residue conservation if you have multiple sequence alignments. 